# -*- coding: utf-8 -*-
"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True






"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True






"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True






"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True






"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True






"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True






"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True






"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True






"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True






"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True




"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True

"""
策略名称: 动量因子策略
策略描述: 基于价格动量的趋势跟踪策略，适用于PTrade平台
作者: 韬睿量化
创建时间: 2024-11-25
PTrade版本: Python 3.11
"""

# PTrade内置模块（在PTrade环境中可用）
# from ptrade import *

import numpy as np
import pandas as pd
from datetime import datetime, timedelta


# ==================== 策略参数 ====================
LOOKBACK_PERIOD = 20        # 动量计算周期
MA_SHORT = 5                # 短期均线
MA_LONG = 20                # 长期均线
MAX_POSITION = 0.1          # 单股最大仓位
MAX_STOCKS = 10             # 最大持股数量
STOP_LOSS = 0.08            # 止损比例
TAKE_PROFIT = 0.20          # 止盈比例
MAX_DRAWDOWN = 0.15         # 最大回撤限制


# ==================== 初始化函数 ====================
def initialize(context):
    """
    初始化函数，在回测开始时调用一次
    
    Args:
        context: 上下文对象，包含账户信息、持仓等
    """
    # 设置基准
    set_benchmark('000300.XSHG')
    
    # 设置滑点
    set_slippage(PriceRelatedSlippage(0.002))
    
    # 设置手续费
    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置股票池（沪深300成分股）
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 策略参数
    context.lookback = LOOKBACK_PERIOD
    context.ma_short = MA_SHORT
    context.ma_long = MA_LONG
    context.max_position = MAX_POSITION
    context.max_stocks = MAX_STOCKS
    context.stop_loss = STOP_LOSS
    context.take_profit = TAKE_PROFIT
    
    # 运行时间设置
    run_daily(before_market_open, time='09:00')
    run_daily(market_open, time='09:30')
    run_daily(after_market_close, time='15:30')
    
    log.info("策略初始化完成")


# ==================== 盘前处理 ====================
def before_market_open(context):
    """
    盘前运行函数
    """
    # 更新股票池
    context.stock_pool = get_index_stocks('000300.XSHG')
    
    # 过滤停牌和ST股票
    context.tradable_stocks = []
    for stock in context.stock_pool:
        if not is_suspended(stock) and not is_st(stock):
            context.tradable_stocks.append(stock)
    
    log.info(f"今日可交易股票数量: {len(context.tradable_stocks)}")


# ==================== 开盘处理 ====================
def market_open(context):
    """
    开盘时运行，执行主要交易逻辑
    """
    # 风险控制检查
    if not risk_control(context):
        return
    
    # 获取当前持仓
    current_positions = list(context.portfolio.positions.keys())
    
    # 计算所有股票的动量得分
    momentum_scores = {}
    
    for stock in context.tradable_stocks:
        score = calculate_momentum_score(stock, context)
        if score is not None:
            momentum_scores[stock] = score
    
    # 按动量得分排序
    sorted_stocks = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
    
    # 获取目标持仓
    target_stocks = [s[0] for s in sorted_stocks[:context.max_stocks]]
    
    # 卖出不在目标列表中的股票
    for stock in current_positions:
        if stock not in target_stocks:
            # 检查止损止盈
            position = context.portfolio.positions[stock]
            current_price = get_current_price(stock)
            cost = position.avg_cost
            
            pnl_ratio = (current_price - cost) / cost
            
            if pnl_ratio <= -context.stop_loss:
                order_target(stock, 0)
                log.info(f"止损卖出 {stock}, 亏损: {pnl_ratio*100:.2f}%")
            elif pnl_ratio >= context.take_profit:
                order_target(stock, 0)
                log.info(f"止盈卖出 {stock}, 盈利: {pnl_ratio*100:.2f}%")
            else:
                order_target(stock, 0)
                log.info(f"调仓卖出 {stock}")
    
    # 买入目标股票
    available_cash = context.portfolio.available_cash
    position_value = available_cash / max(1, context.max_stocks - len(current_positions))
    
    for stock in target_stocks:
        if stock not in current_positions:
            # 计算可买数量
            price = get_current_price(stock)
            if price and price > 0:
                # 限制单股仓位
                max_value = context.portfolio.total_value * context.max_position
                buy_value = min(position_value, max_value)
                
                amount = int(buy_value / price / 100) * 100
                if amount >= 100:
                    order(stock, amount)
                    log.info(f"买入 {stock}, 数量: {amount}, 价格: {price:.2f}")


# ==================== 盘后处理 ====================
def after_market_close(context):
    """
    收盘后运行
    """
    # 记录当日持仓
    positions = context.portfolio.positions
    log.info(f"当日持仓: {len(positions)} 只股票")
    
    # 记录账户信息
    log.info(f"总资产: {context.portfolio.total_value:.2f}")
    log.info(f"可用资金: {context.portfolio.available_cash:.2f}")
    
    # 计算当日收益
    if hasattr(context, 'last_total_value'):
        daily_return = (context.portfolio.total_value - context.last_total_value) / context.last_total_value
        log.info(f"当日收益: {daily_return*100:.2f}%")
    
    context.last_total_value = context.portfolio.total_value


# ==================== 辅助函数 ====================
def calculate_momentum_score(stock, context):
    """
    计算动量得分
    
    Args:
        stock: 股票代码
        context: 上下文
    
    Returns:
        float: 动量得分
    """
    try:
        # 获取历史数据
        df = get_price(stock, count=context.lookback + 10, frequency='1d', 
                      fields=['open', 'high', 'low', 'close', 'volume'])
        
        if df is None or len(df) < context.lookback:
            return None
        
        close = df['close'].values
        volume = df['volume'].values
        
        # 计算动量指标
        # 1. 价格动量（过去N日收益率）
        price_momentum = (close[-1] - close[-context.lookback]) / close[-context.lookback]
        
        # 2. 均线趋势
        ma_short = np.mean(close[-context.ma_short:])
        ma_long = np.mean(close[-context.ma_long:])
        ma_trend = (ma_short - ma_long) / ma_long
        
        # 3. 成交量变化
        vol_ma = np.mean(volume[-context.lookback:])
        vol_ratio = volume[-1] / vol_ma if vol_ma > 0 else 1
        
        # 综合得分
        score = price_momentum * 0.5 + ma_trend * 0.3 + (vol_ratio - 1) * 0.2
        
        return score
        
    except Exception as e:
        log.warn(f"计算 {stock} 动量得分失败: {e}")
        return None


def get_current_price(stock):
    """获取当前价格"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['close'])
        if df is not None and len(df) > 0:
            return df['close'].iloc[-1]
    except:
        pass
    return None


def is_suspended(stock):
    """判断是否停牌"""
    try:
        df = get_price(stock, count=1, frequency='1d', fields=['volume'])
        if df is not None and len(df) > 0:
            return df['volume'].iloc[-1] == 0
    except:
        pass
    return True


def is_st(stock):
    """判断是否为ST股票"""
    try:
        info = get_security_info(stock)
        if info and 'ST' in info.display_name:
            return True
    except:
        pass
    return False


# ==================== 风险控制 ====================
def risk_control(context):
    """
    风险控制函数
    
    Returns:
        bool: 是否通过风控检查
    """
    # 检查最大回撤
    if hasattr(context, 'max_value'):
        context.max_value = max(context.max_value, context.portfolio.total_value)
    else:
        context.max_value = context.portfolio.total_value
    
    drawdown = (context.max_value - context.portfolio.total_value) / context.max_value
    
    if drawdown > MAX_DRAWDOWN:
        log.warn(f"触发最大回撤限制 ({drawdown*100:.2f}%)，清仓")
        for stock in list(context.portfolio.positions.keys()):
            order_target(stock, 0)
        return False
    
    return True














