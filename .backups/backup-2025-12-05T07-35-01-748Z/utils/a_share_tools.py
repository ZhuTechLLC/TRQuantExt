# -*- coding: utf-8 -*-
"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)






"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)






"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)






"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)






"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)






"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)






"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)






"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)






"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)






"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)




"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)

"""
A股市场专业工具
深度适配中国A股市场特性
"""
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, timedelta
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MarketType(Enum):
    """市场类型"""
    SH = "sh"      # 上海
    SZ = "sz"      # 深圳
    BJ = "bj"      # 北交所


class BoardType(Enum):
    """板块类型"""
    MAIN = "main"           # 主板
    SME = "sme"             # 中小板
    GEM = "gem"             # 创业板
    STAR = "star"           # 科创板
    BSE = "bse"             # 北交所


class AShareCodeParser:
    """
    A股代码解析器
    
    支持解析各种格式的股票代码，自动识别市场和板块
    """
    
    # 代码前缀规则
    CODE_RULES = {
        # 上海主板
        '600': (MarketType.SH, BoardType.MAIN),
        '601': (MarketType.SH, BoardType.MAIN),
        '603': (MarketType.SH, BoardType.MAIN),
        '605': (MarketType.SH, BoardType.MAIN),
        # 科创板
        '688': (MarketType.SH, BoardType.STAR),
        '689': (MarketType.SH, BoardType.STAR),
        # 上海B股
        '900': (MarketType.SH, BoardType.MAIN),
        # 深圳主板
        '000': (MarketType.SZ, BoardType.MAIN),
        '001': (MarketType.SZ, BoardType.MAIN),
        # 中小板
        '002': (MarketType.SZ, BoardType.SME),
        # 创业板
        '300': (MarketType.SZ, BoardType.GEM),
        '301': (MarketType.SZ, BoardType.GEM),
        # 深圳B股
        '200': (MarketType.SZ, BoardType.MAIN),
        # 北交所
        '8': (MarketType.BJ, BoardType.BSE),
        '4': (MarketType.BJ, BoardType.BSE),
    }
    
    @classmethod
    def parse(cls, code: str) -> Tuple[str, MarketType, BoardType]:
        """
        解析股票代码
        
        Args:
            code: 股票代码（支持多种格式）
        
        Returns:
            Tuple[str, MarketType, BoardType]: (纯代码, 市场, 板块)
        """
        # 清理代码
        code = code.strip().upper()
        
        # 移除后缀
        for suffix in ['.SH', '.SZ', '.BJ', '.XSHG', '.XSHE']:
            if code.endswith(suffix):
                code = code[:-len(suffix)]
                break
        
        # 移除前缀
        for prefix in ['SH', 'SZ', 'BJ']:
            if code.startswith(prefix):
                code = code[len(prefix):]
                break
        
        # 识别市场和板块
        for prefix, (market, board) in cls.CODE_RULES.items():
            if code.startswith(prefix):
                return code, market, board
        
        # 默认返回
        return code, MarketType.SH, BoardType.MAIN
    
    @classmethod
    def to_jqdata(cls, code: str) -> str:
        """转换为聚宽格式 (000001.XSHE)"""
        code, market, _ = cls.parse(code)
        suffix = '.XSHG' if market == MarketType.SH else '.XSHE'
        return f"{code}{suffix}"
    
    @classmethod
    def to_qmt(cls, code: str) -> str:
        """转换为QMT格式 (000001.SZ)"""
        code, market, _ = cls.parse(code)
        suffix = '.SH' if market == MarketType.SH else '.SZ'
        return f"{code}{suffix}"
    
    @classmethod
    def to_tushare(cls, code: str) -> str:
        """转换为TuShare格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def to_wind(cls, code: str) -> str:
        """转换为Wind格式 (000001.SZ)"""
        return cls.to_qmt(code)
    
    @classmethod
    def get_board(cls, code: str) -> BoardType:
        """获取板块类型"""
        _, _, board = cls.parse(code)
        return board
    
    @classmethod
    def is_star_market(cls, code: str) -> bool:
        """是否科创板"""
        return cls.get_board(code) == BoardType.STAR
    
    @classmethod
    def is_gem(cls, code: str) -> bool:
        """是否创业板"""
        return cls.get_board(code) == BoardType.GEM


class AShareTradingRules:
    """
    A股交易规则
    
    封装A股特有的交易规则，如T+1、涨跌停、集合竞价等
    """
    
    # 涨跌停幅度
    LIMIT_RATES = {
        BoardType.MAIN: 0.10,    # 主板 10%
        BoardType.SME: 0.10,     # 中小板 10%
        BoardType.GEM: 0.20,     # 创业板 20%
        BoardType.STAR: 0.20,    # 科创板 20%
        BoardType.BSE: 0.30,     # 北交所 30%
    }
    
    # 最小交易单位
    MIN_LOT_SIZE = {
        BoardType.MAIN: 100,     # 主板 100股
        BoardType.SME: 100,      # 中小板 100股
        BoardType.GEM: 100,      # 创业板 100股
        BoardType.STAR: 200,     # 科创板 200股
        BoardType.BSE: 100,      # 北交所 100股
    }
    
    @classmethod
    def get_limit_rate(cls, code: str) -> float:
        """获取涨跌停幅度"""
        board = AShareCodeParser.get_board(code)
        return cls.LIMIT_RATES.get(board, 0.10)
    
    @classmethod
    def get_min_lot(cls, code: str) -> int:
        """获取最小交易单位"""
        board = AShareCodeParser.get_board(code)
        return cls.MIN_LOT_SIZE.get(board, 100)
    
    @classmethod
    def calc_limit_price(cls, code: str, pre_close: float) -> Tuple[float, float]:
        """
        计算涨跌停价格
        
        Args:
            code: 股票代码
            pre_close: 昨收价
        
        Returns:
            Tuple[float, float]: (涨停价, 跌停价)
        """
        rate = cls.get_limit_rate(code)
        limit_up = round(pre_close * (1 + rate), 2)
        limit_down = round(pre_close * (1 - rate), 2)
        return limit_up, limit_down
    
    @classmethod
    def round_lot(cls, code: str, quantity: int) -> int:
        """
        调整为合法交易数量（整手）
        
        Args:
            code: 股票代码
            quantity: 原始数量
        
        Returns:
            int: 调整后的数量
        """
        min_lot = cls.get_min_lot(code)
        return (quantity // min_lot) * min_lot
    
    @classmethod
    def is_t_plus_1(cls, code: str) -> bool:
        """是否T+1交易"""
        # A股都是T+1
        return True
    
    @classmethod
    def can_sell_today(cls, code: str, buy_date: date) -> bool:
        """今日买入是否可以卖出"""
        # T+1规则，当日买入不可卖出
        return buy_date < date.today()


class AShareTradingCalendar:
    """
    A股交易日历
    
    管理交易日、节假日等
    """
    
    # 交易时间段
    TRADING_SESSIONS = [
        ('09:30', '11:30'),  # 上午
        ('13:00', '15:00'),  # 下午
    ]
    
    # 集合竞价时间
    CALL_AUCTION = [
        ('09:15', '09:25'),  # 开盘集合竞价
        ('14:57', '15:00'),  # 收盘集合竞价
    ]
    
    _trading_days_cache = {}
    
    @classmethod
    def is_trading_time(cls, dt: datetime = None) -> bool:
        """
        是否交易时间
        
        Args:
            dt: 时间，默认当前时间
        
        Returns:
            bool: 是否在交易时间内
        """
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.TRADING_SESSIONS:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def is_call_auction(cls, dt: datetime = None) -> bool:
        """是否集合竞价时间"""
        if dt is None:
            dt = datetime.now()
        
        time_str = dt.strftime('%H:%M')
        
        for start, end in cls.CALL_AUCTION:
            if start <= time_str <= end:
                return True
        
        return False
    
    @classmethod
    def get_trading_days(cls, start_date: str, end_date: str) -> List[str]:
        """
        获取交易日列表
        
        Args:
            start_date: 开始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
        
        Returns:
            List[str]: 交易日列表
        """
        cache_key = f"{start_date}_{end_date}"
        if cache_key in cls._trading_days_cache:
            return cls._trading_days_cache[cache_key]
        
        try:
            import jqdatasdk as jq
            days = jq.get_trade_days(start_date=start_date, end_date=end_date)
            result = [d.strftime('%Y-%m-%d') for d in days]
            cls._trading_days_cache[cache_key] = result
            return result
        except:
            # 如果无法获取，返回简单的工作日列表
            result = []
            current = datetime.strptime(start_date, '%Y-%m-%d')
            end = datetime.strptime(end_date, '%Y-%m-%d')
            
            while current <= end:
                if current.weekday() < 5:  # 周一到周五
                    result.append(current.strftime('%Y-%m-%d'))
                current += timedelta(days=1)
            
            return result
    
    @classmethod
    def is_trading_day(cls, dt: date = None) -> bool:
        """是否交易日"""
        if dt is None:
            dt = date.today()
        
        # 周末不交易
        if dt.weekday() >= 5:
            return False
        
        # TODO: 检查节假日
        return True
    
    @classmethod
    def get_next_trading_day(cls, dt: date = None) -> date:
        """获取下一个交易日"""
        if dt is None:
            dt = date.today()
        
        next_day = dt + timedelta(days=1)
        while not cls.is_trading_day(next_day):
            next_day += timedelta(days=1)
        
        return next_day
    
    @classmethod
    def get_prev_trading_day(cls, dt: date = None) -> date:
        """获取上一个交易日"""
        if dt is None:
            dt = date.today()
        
        prev_day = dt - timedelta(days=1)
        while not cls.is_trading_day(prev_day):
            prev_day -= timedelta(days=1)
        
        return prev_day


class AShareRiskControl:
    """
    A股风险控制
    
    针对A股市场特性的风险控制规则
    """
    
    def __init__(self):
        self.max_position_ratio = 0.8       # 最大仓位比例
        self.single_stock_limit = 0.2       # 单股持仓上限
        self.daily_loss_limit = 0.05        # 日亏损限制
        self.stop_loss_ratio = 0.08         # 个股止损比例
        self.stop_profit_ratio = 0.15       # 个股止盈比例
        self.max_orders_per_day = 50        # 每日最大委托数
        self.min_order_interval = 3         # 最小下单间隔（秒）
        
        self._last_order_time = None
        self._daily_orders = 0
        self._daily_loss = 0
    
    def check_position_limit(self, total_asset: float, position_value: float, 
                             new_order_value: float) -> Tuple[bool, str]:
        """
        检查仓位限制
        
        Args:
            total_asset: 总资产
            position_value: 当前持仓市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (position_value + new_order_value) / total_asset
        
        if new_ratio > self.max_position_ratio:
            return False, f"超过最大仓位限制 ({self.max_position_ratio*100}%)"
        
        return True, ""
    
    def check_single_stock_limit(self, total_asset: float, stock_value: float,
                                  new_order_value: float) -> Tuple[bool, str]:
        """
        检查单股持仓限制
        
        Args:
            total_asset: 总资产
            stock_value: 该股票当前市值
            new_order_value: 新订单金额
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        new_ratio = (stock_value + new_order_value) / total_asset
        
        if new_ratio > self.single_stock_limit:
            return False, f"超过单股持仓上限 ({self.single_stock_limit*100}%)"
        
        return True, ""
    
    def check_daily_loss(self, current_loss: float, total_asset: float) -> Tuple[bool, str]:
        """
        检查日亏损限制
        
        Args:
            current_loss: 当前日亏损
            total_asset: 总资产
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        loss_ratio = abs(current_loss) / total_asset
        
        if loss_ratio > self.daily_loss_limit:
            return False, f"触发日亏损限制 ({self.daily_loss_limit*100}%)"
        
        return True, ""
    
    def check_order_frequency(self) -> Tuple[bool, str]:
        """
        检查下单频率
        
        Returns:
            Tuple[bool, str]: (是否通过, 原因)
        """
        now = datetime.now()
        
        # 检查每日委托数
        if self._daily_orders >= self.max_orders_per_day:
            return False, f"超过每日最大委托数 ({self.max_orders_per_day})"
        
        # 检查下单间隔
        if self._last_order_time:
            interval = (now - self._last_order_time).total_seconds()
            if interval < self.min_order_interval:
                return False, f"下单过于频繁，请等待 {self.min_order_interval - interval:.1f} 秒"
        
        return True, ""
    
    def check_stop_loss(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止损条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止损, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        loss_ratio = (cost_price - current_price) / cost_price
        
        if loss_ratio >= self.stop_loss_ratio:
            return True, f"触发止损 (亏损 {loss_ratio*100:.1f}%)"
        
        return False, ""
    
    def check_stop_profit(self, cost_price: float, current_price: float) -> Tuple[bool, str]:
        """
        检查止盈条件
        
        Args:
            cost_price: 成本价
            current_price: 现价
        
        Returns:
            Tuple[bool, str]: (是否触发止盈, 原因)
        """
        if cost_price <= 0:
            return False, ""
        
        profit_ratio = (current_price - cost_price) / cost_price
        
        if profit_ratio >= self.stop_profit_ratio:
            return True, f"触发止盈 (盈利 {profit_ratio*100:.1f}%)"
        
        return False, ""
    
    def record_order(self):
        """记录下单"""
        self._last_order_time = datetime.now()
        self._daily_orders += 1
    
    def reset_daily(self):
        """重置每日计数"""
        self._daily_orders = 0
        self._daily_loss = 0


# 便捷函数
def normalize_code(code: str, target: str = 'jqdata') -> str:
    """
    标准化股票代码
    
    Args:
        code: 原始代码
        target: 目标格式 (jqdata, qmt, tushare, wind)
    
    Returns:
        str: 标准化后的代码
    """
    converters = {
        'jqdata': AShareCodeParser.to_jqdata,
        'qmt': AShareCodeParser.to_qmt,
        'tushare': AShareCodeParser.to_tushare,
        'wind': AShareCodeParser.to_wind,
    }
    
    converter = converters.get(target.lower(), AShareCodeParser.to_jqdata)
    return converter(code)


def get_limit_prices(code: str, pre_close: float) -> Dict[str, float]:
    """
    获取涨跌停价格
    
    Args:
        code: 股票代码
        pre_close: 昨收价
    
    Returns:
        Dict: {'limit_up': 涨停价, 'limit_down': 跌停价}
    """
    limit_up, limit_down = AShareTradingRules.calc_limit_price(code, pre_close)
    return {
        'limit_up': limit_up,
        'limit_down': limit_down,
    }


def is_trading_time() -> bool:
    """当前是否交易时间"""
    return AShareTradingCalendar.is_trading_time()


def is_trading_day(dt: date = None) -> bool:
    """是否交易日"""
    return AShareTradingCalendar.is_trading_day(dt)














